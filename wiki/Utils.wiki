#summary Documentation for the utils.h file

= utils.h =



== Functions ==

class min(class T, const T & v1, const T & v2)
  **
class max(class T, const T & v1, const T & v2)
  **
class clamp(class T, const T & value, const T & minValue, const T & maxValue)
  **
class mod(class T, const T & value, const T & minValue, const T & maxValue)
  **
class reflect(class T, const T & value, const T & minValue, const T & maxValue)
  **
class lerp(class T, const T & value, const T & inputMin, const T & inputMax, const T & outputMin, const T & outputMax)
  **
class sigmoid(class T, const T & value, const T & inputMin, const T & inputMax, const T & outputMin, const T & outputMax)
  **
class ramp(class T, const T & value, const T & inputMin, const T & inputMax, const T & outputMin, const T & outputMax)
  **
class line(class T, const T & value, const T & inputMin, const T & inputMax, const T & outputMin, const T & outputMax)
  **
class step(class T, const T & input, const T & inputThreshold, const T & outputMin, const T & outputMax)
  **
class frac(class T, T x)
  **
class floor(class T, T x)
  **
class extreme(class T, T v1, T v2, T center)
  **

== Detailed Description ==




== Function Documentation ==

{{{
#class min   (
  class T,
  const T & v1,
  const T & v2  )
}}}
  
  

*Parameters*:
  a   And two parameters. 
  b   Here's the second. 
*Returns*:
  And a return value!

{{{
#class max   (
  class T,
  const T & v1,
  const T & v2  )
}}}
  
  

*Parameters*:
  a   And two parameters. 
  b   Here's the second. 
*Returns*:
  And a return value!

{{{
#class clamp   (
  class T,
  const T & value,
  const T & minValue,
  const T & maxValue  )
}}}
  
  Returns the given value clamped between the given minimum and maximum.


A value clamped between minValue and maxValue.



The range of this function includes the maxValue.

*Parameters*:
  a   And two parameters. 
  b   Here's the second. 
*Returns*:
  And a return value!

{{{
#class mod   (
  class T,
  const T & value,
  const T & minValue,
  const T & maxValue  )
}}}
  
  Returns the modulus of a number in a specified range, that is (min + value mod (max - min)).

For example,

*        **for** (**int** i = 0; i < 10; i++)*
*        {*
*                **int** r = mod(i, 2, 5);*
*                cout << i << **" "**;*
*        }*

prints 3 4 2 3 4 2 3 4 2 3

The range of this function excludes the maxValue.

*Parameters*:
  a   And two parameters. 
  b   Here's the second. 
*Returns*:
  And a return value!

{{{
#class reflect   (
  class T,
  const T & value,
  const T & minValue,
  const T & maxValue  )
}}}
  
  Returns a number reflected between the bounds.

For example,

*        **for** (**int** i = 0; i < 10; i++)*
*        {*
*                **int** r = reflect(i, 0, 3);*
*                cout << i << **" "**;*
*        }*

prints 0 1 2 3 2 1 0 1 2 3

The range of this function includes the maxValue.

*Parameters*:
  a   And two parameters. 
  b   Here's the second. 
*Returns*:
  And a return value!

{{{
#class lerp   (
  class T,
  const T & value,
  const T & inputMin,
  const T & inputMax,
  const T & outputMin,
  const T & outputMax  )
}}}
  
  Linearly interpolates a value between a given range.

If the value is below the inputMin, the outputMin is returned. If the value is above the inputMax, the outputMax is returned.

Otherwise, the returned value is outputMin + ((value - inputMin) / (inputMax - inputMin)) * (outputMax - outputMin).

Luke Lamothe ([mailto:luke@luma.co.za luke@luma.co.za])

*Parameters*:
  a   And two parameters. 
  b   Here's the second. 
*Returns*:
  And a return value!

{{{
#class sigmoid   (
  class T,
  const T & value,
  const T & inputMin,
  const T & inputMax,
  const T & outputMin,
  const T & outputMax  )
}}}
  
  This function is a smooth aproximation for lerp.

*Parameters*:
  a   And two parameters. 
  b   Here's the second. 
*Returns*:
  And a return value!

{{{
#class ramp   (
  class T,
  const T & value,
  const T & inputMin,
  const T & inputMax,
  const T & outputMin,
  const T & outputMax  )
}}}
  
  If the value is below the inputMin, the outputMin is returned.

Otherwise, the returned value is outputMin + ((value - inputMin) / (inputMax - inputMin)) * (outputMax - outputMin).

*Parameters*:
  a   And two parameters. 
  b   Here's the second. 
*Returns*:
  And a return value!

{{{
#class line   (
  class T,
  const T & value,
  const T & inputMin,
  const T & inputMax,
  const T & outputMin,
  const T & outputMax  )
}}}
  
  Otherwise, the returned value is outputMin + ((value - inputMin) / (inputMax - inputMin)) * (outputMax - outputMin).

*Parameters*:
  a   And two parameters. 
  b   Here's the second. 
*Returns*:
  And a return value!

{{{
#class step   (
  class T,
  const T & input,
  const T & inputThreshold,
  const T & outputMin,
  const T & outputMax  )
}}}
  
  Returns the one of two outputs, depending on whether the input value exceeds a given threshold.

*Parameters*:
  a   And two parameters. 
  b   Here's the second. 
*Returns*:
  And a return value!

{{{
#class frac   (
  class T,
  T x  )
}}}
  
  Returns the fractional part of a float or double. Guarenteed always to lie between 0 and 1, even if the input is negative.

: the following identity hold (within floating point threshold): 
*                x == frac(c) + floor(x)*




floor()

*Parameters*:
  a   And two parameters. 
  b   Here's the second. 
*Returns*:
  And a return value!

{{{
#class floor   (
  class T,
  T x  )
}}}
  
  Returns the largest integer smaller than the argument given.

frac()

*Parameters*:
  a   And two parameters. 
  b   Here's the second. 
*Returns*:
  And a return value!

{{{
#class extreme   (
  class T,
  T v1,
  T v2,
  T center  )
}}}
  
  Returns the value furthest from the center. For example, 
*        extreme(-1, 5, 0) == 5*
*        extreme(1, -5, 0) == -5*


This is useful, for example when deciding on which of two (polar opposite) inputs to use to make a decision.

*Parameters*:
  a   And two parameters. 
  b   Here's the second. 
*Returns*:
  And a return value!

---
|| [Doxygen Main Page] || [Doxygen_files Files] ||